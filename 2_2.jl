using Gurobi,JuMP
using Plots, Random, Printf, XLSX, CSV, DataFrames, Distributions, MathOptInterface

# SETS and DATA

GEN_S=["S1","S2","S3","S4"]                  # price MAKER generators
GEN_O=["O1","O2","O3","O4"]                  # price TAKER generators
DEMAND=["D1","D2","D3","D4"]                 # demand
NODE=["N1","N2","N3","N4","N5","N6"]         # nodes

S=length(GEN_S)
O=length(GEN_O)
D=length(DEMAND)
N=length(NODE)

D_Location=[3 4 5 6]    # demand location
S_Location=[1 2 3 6]    # price MAKER generators locations
O_Location=[1 2 3 5]    # price TAKER generators locations

D_quantity=[200 400 300 250]          # MW
D_bid_price=[26.5 24.7 23.1 22.5]     # €/MWh

S_capacity=[155 100 155 197]          # MW
O_capacity=[0.75*450 350 210 80]      # MW

S_cost=[15.2 23.4 15.2 19.1]     # euro/MWh
O_cost=[0 5 20.1 24.7]           # euro/MWh

S_ramp=[90 85 90 120]    # MW/h
O_ramp=[0 350 170 80]    # MW/h

susceptance=50
BB=1/susceptance

Big_M = 10^4


TWO_TWO= Model(Gurobi.Optimizer)

@variable(TWO_TWO, S_prod[1:S])      # Power generated by MAKER
@variable(TWO_TWO, O_prod[1:O])      # Power generated by TAKER

@variable(TWO_TWO, lambda)           # without network constraint we considered just one price in this model - in 2.3 different nodes are considered
                                     # in 2.3 with enough capacity of the lines, the result is exactly the same 
                                     #(the only thing that could change is S1 and S3 the other way around because they have the same features)

@variable(TWO_TWO, S_alpha_offer[1:S])        # offer price of strategic producer
@variable(TWO_TWO, demand[1:D])               # demand covered

@variable(TWO_TWO, mu_D_up[1:D])
@variable(TWO_TWO, mu_D_down[1:D])

@variable(TWO_TWO, mu_O_up[1:O])
@variable(TWO_TWO, mu_O_down[1:O])

@variable(TWO_TWO, mu_S_up[1:S])
@variable(TWO_TWO, mu_S_down[1:S])

@variable(TWO_TWO, epsi_D_up[1:D],Bin)                                                     # 11
@variable(TWO_TWO, epsi_D_down[1:D],Bin)                                                   # 16

@variable(TWO_TWO, epsi_O_up[1:O],Bin)                                                     # 21
@variable(TWO_TWO, epsi_O_down[1:O],Bin)                                                   # 26

@variable(TWO_TWO, epsi_S_up[1:S], Bin)                                                    # 31
@variable(TWO_TWO, epsi_S_down[1:S], Bin)                                                  # 36

#@constraint(TWO_TWO,[s=1:S], S_alpha_offer[s] >= S_cost[s])                                 # 1
@constraint(TWO_TWO,[s=1:S], S_alpha_offer[s]>=0)                                           # 2
@constraint(TWO_TWO,[d=1:D], - D_bid_price[d] + mu_D_up[d] - mu_D_down[d] + lambda == 0)    # 3
@constraint(TWO_TWO,[s=1:S], S_alpha_offer[s] + mu_S_up[s] - mu_S_down[s] - lambda == 0)    # 4
@constraint(TWO_TWO,[o=1:O], O_cost[o] + mu_O_up[o] - mu_O_down[o] - lambda == 0)           # 5
@constraint(TWO_TWO, sum(demand[d] for d=1:D) - sum(S_prod[s] for s=1:S) - sum(O_prod[o] for o=1:O) == 0) # 6  power balance

# DEMAND

@constraint(TWO_TWO, [d=1:D], demand[d]<=D_quantity[d])                                     # 7  capacity constraint
@constraint(TWO_TWO,[d=1:D], mu_D_up[d]>=0)                                                 # 8
@constraint(TWO_TWO, [d=1:D], D_quantity[d] - demand[d] <= epsi_D_up[d]*Big_M)              # 9
@constraint(TWO_TWO,[d=1:D], mu_D_up[d] <= (1 - epsi_D_up[d])*Big_M)                        # 10
# 11 is in the variable
@constraint(TWO_TWO,[d=1:D], demand[d] >= 0)                                                # 12
@constraint(TWO_TWO,[d=1:D], mu_D_down[d] >= 0)                                             # 13
@constraint(TWO_TWO,[d=1:D], demand[d] <= epsi_D_down[d]*Big_M)                             # 14
@constraint(TWO_TWO,[d=1:D], mu_D_down[d] <= (1 - epsi_D_down[d])*Big_M)                    # 15
# 16 is in the variable

# PRICE MAKER - LEADER - S

@constraint(TWO_TWO, [s=1:S], S_prod[s]<=S_capacity[s])                                     # 17  capacity constraint
@constraint(TWO_TWO,[s=1:S], mu_S_up[s]>=0)                                                 # 18
@constraint(TWO_TWO, [s=1:S], S_capacity[s] - S_prod[s] <= epsi_S_up[s]*Big_M)              # 19
@constraint(TWO_TWO,[s=1:S], mu_S_up[s] <= (1 - epsi_S_up[s])*Big_M)                        # 20
                                                                                            # 21 is in the variable
@constraint(TWO_TWO,[s=1:S], S_prod[s] >= 0)                                                # 22
@constraint(TWO_TWO,[s=1:S], mu_S_down[s] >= 0)                                             # 23
@constraint(TWO_TWO,[s=1:S], S_prod[s] <= epsi_S_down[s]*Big_M)                             # 24
@constraint(TWO_TWO,[s=1:S], mu_S_down[s] <= (1 - epsi_S_down[s])*Big_M)                    # 25
                                                                                            # 26 is in the variable

# PRICE TAKER - FOLLOWERS - O

@constraint(TWO_TWO, [o=1:O], O_prod[o]<=O_capacity[o])                                     # 27  capacity constraint
@constraint(TWO_TWO,[o=1:O], mu_O_up[o]>=0)                                                 # 28
@constraint(TWO_TWO, [o=1:O], O_capacity[o] - O_prod[o] <= epsi_O_up[o]*Big_M)              # 29
@constraint(TWO_TWO,[o=1:O], mu_O_up[o] <= (1 - epsi_O_up[o])*Big_M)                        # 30
                                                                                            # 31 is in the variable
@constraint(TWO_TWO,[o=1:O], O_prod[o] >= 0)                                                # 32
@constraint(TWO_TWO,[o=1:O], mu_O_down[o] >= 0)                                             # 33
@constraint(TWO_TWO,[o=1:O], O_prod[o] <= epsi_O_down[o]*Big_M)                             # 34
@constraint(TWO_TWO,[o=1:O], mu_O_down[o] <= (1 - epsi_O_down[o])*Big_M)                    # 35
                                                                                            # 36 is in the variable

@objective(TWO_TWO, Max, - sum(S_prod[s]*S_cost[s] for s=1:S)
                         + sum(D_bid_price[d]*demand[d] for d=1:D)
                         - sum(O_cost[o]*O_prod[o] for o=1:O)
                         - sum(mu_D_up[d]*D_quantity[d] for d=1:D)
                         - sum(mu_O_up[o]*O_capacity[o] for o=1:O)
)

start_time = time()
optimize!(TWO_TWO)
end_time = time()




########################## DATA VISUALIZATION ###############################################


for s=1:S
    println("Offer Price ", GEN_S[s], @sprintf(" %.2f €/MWh" , value(S_alpha_offer[s]))," - Production cost: ", @sprintf(" %.2f €/MWh" , S_cost[s]))
end 

println("\n")

market_price=value(lambda)

S_production=zeros(S)
S_profit=zeros(S)
D_welfare=zeros(D)

for s=1:S
    S_production[s]=value(S_prod[s])
    S_profit[s]=S_production[s]*(market_price-S_cost[s])
    println("Power Production ", GEN_S[s], @sprintf(" %.2f MWh" , value(S_prod[s]))," - Production cost: ", @sprintf(" %.2f €/MWh" , S_cost[s]), " - Profit: ", @sprintf("%.2f" , S_profit[s]), " €"  )
end 
println("\n")

O_production=zeros(O)
O_profit=zeros(O)


for o=1:O
    O_production[o]=value(O_prod[o])
    O_profit[o]=O_production[o]*(market_price-O_cost[o])

    println("Power Production ", GEN_O[o], @sprintf(" %.2f MWh" , value(O_prod[o]))," - Production cost: ", @sprintf(" %.2f €/MWh" , O_cost[o]), " - Profit: ", @sprintf("%.2f" , O_profit[o]), " €" )
end

for d=1:D
    D_welfare[d]=value(demand[d])*(D_bid_price[d]-market_price)
end

println("\n")
Social_welfare=sum(D_welfare[d] for d=1:D) + sum(O_profit[o] for o=1:O) + sum(S_profit[s] for s=1:S)

println("Social Welfare: ", @sprintf("%.2f \$", Social_welfare))


println("\n")
println(@sprintf("Market clearing price: %.2f €/MWh" , value(lambda)))

# Print number of variables and constraints
println("Number of variables: ", JuMP.num_variables(TWO_TWO))
println("Number of constraints: ", JuMP.num_constraints(TWO_TWO, count_variable_in_set_constraints=false))


# Print computational time
println("Computational time: ", end_time - start_time)
