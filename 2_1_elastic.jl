using Gurobi,JuMP
using Plots, Random, Printf, XLSX, CSV, DataFrames, Distributions, MathOptInterface

# SETS and DATA

GEN_S=["S1","S2","S3","S4"]                  # price maker generators
GEN_O=["O1","O2","O3","O4"]                  # price taker generators
DEMAND=["D1","D2","D3","D4"]                 # demand
NODE=["N1","N2","N3","N4","N5","N6"]         # nodes

S=length(GEN_S)
O=length(GEN_O)
D=length(DEMAND)
N=length(NODE)

D_Location=[3 4 5 6]    # demand location
S_Location=[1 2 3 6]    # price maker generators locations
O_Location=[1 2 3 5]    # price taker generators locations

D_quantity=[200 400 300 250]         # MW
D_bid_price=[26.5 24.7 23.1 22.5]    # €/MWh

S_capacity=[155 100 155 197]         # MW
O_capacity=[0.75*450 350 210 80]      # MW

S_cost=[15.2 23.4 15.2 19.1]     # euro/MWh
O_cost=[0 5 20.1 24.7]           # euro/MWh

S_ramp=[90 85 90 120]    # MW/h
O_ramp=[0 350 170 80]    # MW/h

susceptance=50
BB=1/susceptance


TWO_ONE= Model(Gurobi.Optimizer)

@variable(TWO_ONE, S_prod[1:S])                   # Power generated by MAKER
@variable(TWO_ONE, O_prod[1:O]>=0)                # Power generated by TAKER
@variable(TWO_ONE, theta[1:N])                    # voltage angle
@variable(TWO_ONE, demand[1:D]>=0)                # demand covered

@constraint(TWO_ONE, [s=1:S], S_prod[s]<=S_capacity[s])                    # capacity contraint S
@constraint(TWO_ONE, [s=1:S], S_prod[s]>=0) 
@constraint(TWO_ONE, [o=1:O], O_prod[o]<=O_capacity[o])                    # capacity contraint O
@constraint(TWO_ONE, theta[1]==0)                                          # theta of node 1 =0
@constraint(TWO_ONE, [d=1:D], demand[d]<=D_quantity[d])                    # capacity contraint D


@constraint(TWO_ONE, lambda[n=1:N],
                                                  - sum(demand[d]*(D_Location[d]==n ? 1 : 0) for d=1:D)          # if the demand is located in the right node then it is taken into account otherwise not
                                                  + sum(S_prod[s]*(S_Location[s]==n ? 1 : 0) for s=1:S)          # same for the production S and O      
                                                  + sum(O_prod[o]*(O_Location[o]==n ? 1 : 0) for o=1:O)                 
                                                  - sum(BB*(theta[n]-theta[m]) for m=1:N) == 0)                  # power balance

@objective(TWO_ONE,Max, sum(D_bid_price[d]*demand[d] for d=1:D) - sum(S_cost[s]*S_prod[s] for s=1:S) - sum(O_cost[o]*O_prod[o] for o=1:O))       # max social welfare

start_time = time()
optimize!(TWO_ONE)
end_time = time()


################ VISUALIZATION ###################



println("MARKET PRICES: \n")

market_price=zeros(N)

for n=1:N
    market_price[n]=value(dual.(lambda[n]))
    println(NODE[n], ": ", @sprintf("%.2f" , market_price[n]))
end


println(" \n")
println("PRODUCTION: \n")

S_profit=zeros(S)
O_profit=zeros(O)

S_production=zeros(S)

for s=1:S
    S_production[s]=value(S_prod[s])
    S_profit[s]=S_production[s]*(market_price[1]-S_cost[s])
    println(GEN_S[s], ": ", @sprintf("%.2f" , S_production[s]), " MWh - Production Cost: ", @sprintf("%.2f" , S_cost[s]), " €/MWh", " - Profit ", GEN_S[s], ": ", @sprintf("%.2f" , S_profit[s]), " €"  )
end

O_production=zeros(O)

for o=1:O
    O_production[o]=value(O_prod[o])
    O_profit[o]=O_production[o]*(market_price[1]-O_cost[o])
    println(GEN_O[o], ": ", @sprintf("%.2f" , O_production[o]), " MWh - Production Cost: ", @sprintf("%.2f" , O_cost[o]), " €/MWh", " - Profit ", GEN_O[o], ": ", @sprintf("%.2f" , O_profit[o]), " €" )
end


println("\n")


for d=1:D
    println("Demand covered ", DEMAND[d], @sprintf(" %.2f \$" , value(demand[d]))," - Demand max: ", @sprintf(" %.2f \$" , D_quantity[d]))
end 


# Print number of variables and constraints
println("\n")
println("Number of variables: ", JuMP.num_variables(TWO_ONE))
println("Number of constraints: ", JuMP.num_constraints(TWO_ONE, count_variable_in_set_constraints=false))


# Print computational time
println("Computational time: ", end_time - start_time)